- 封闭性:
   - 在类中保存数据
   - 封闭性的打破:i.e 可以直接修改类内部的变量,没有通过正确入口进入,可能会导致校验的缺失,对类中其他方法的使用带来问题.
   - 所以才有现在类中的\_\_init\_\_方法,私有属性等,防止类中的值被从外部直接修改
- 类属性:
  
    - 猜测:类和实例处于两个不同的内存空间,类有类属性,实例化后也有自己的实例属性,但是为了节约内存,实例当中不会拷贝类中所有的属性,只有在需要调用的时候才会去找.因此在没有对实例中的实例属性进行修改时,就对实例中的类属性进行删除,等价于对未实例化的类中的类属性进行删除,而对于这种行为,python是不支持的,会报错.但是如果在实例中,对实例的实例属性进行了修改,就能够使得调用实例属性时,不用再去从类中进行查找,此时再删除实例属性,就不会报错.删除后再调用实例属性,又会从类中进行引用.
    
- 类的继承:
    - 继承类拥有父类的属性和方法,相同功能条件下不必重写
    - 继承类并新建的类方法,并不会被其他继承相同父类的继承类所公用
- 多态:
    - 继承类有相同属性或方法,但功能不一样的现象
    - python内建方法中很多实现了多态,比如len(),其本质是调用对象的\_\_len\_\_方法,虽然都是len(),但是所对应的行为却并不一样,而是各自为战.
- 类同名方法或属性的继承或使用顺序:
    - 新式类-广度优先:Python3和Python2(object),新式类的MRO是按照 《拓扑排序算法》 规则，用的是C3算法。https://blog.csdn.net/u011467553/article/details/81437780
    
      快速记忆:![多继承UML图：](https://img-blog.csdn.net/20160912114102701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
    
      查找顺序是:A-B-D-C-E-F-O
    
        - 更为简单的方式是直接调用函数,查看调用顺序
        
          ```类.mro()```
    - 经典类-深度优先:Python2()
    - 为了减少重复查找,根节点会在后面的类中查找: D -> B -> A -> C -> A.优化为了D -> B -> C -> A
- 实例方法(instance method or bound method):
    - 通过'self'实现从类到实例的拷贝,表示的是实例的内存地址
    - 实例方法只能通过实例使用,使用未实例的类无法使用实例的方法
- 类方法:参数中没有'self',可以直接通过类调用,且不能通过实例化调用.
- 实例方法与类方法的理解:实例方法在创建时,会自动给方法传入一个参数'self',表示的就是该方法的地址,所以类方法不能实例后使用,实例方法不能用类来使用
- 装饰器:
    - 闭包
    - 被修饰函数内部的内容没有被改变,只是增加了上下文.
    - 被修饰函数有参数,在装饰器函数内部函数中带上相同的参数
    - 装饰器函数有参数,在外层函数中带上传入的函数形参之外,还要带上自己需要的参数
    - 应用:
        - 添加被装饰函数不具备的一些功能,如异常处理
        - 函数装饰器
        - 类装饰器:
            - 装饰器函数内部是一个类,继承了被装饰的类,这样就可以重写了.然后返回重写后的类名即可.
        - 内建装饰器:
            - @classmethod:把实例方法变成类方法,且不用去掉原有的`self`,可以降低内存的开销,不用非得实例化才能访问,且实例化之后仍能访问
            - @staticmethod:不需要实例化使用,且不需要传入地址参数.而且实例化后仍能使用,不像类方法或实例方法那样,不能在对方的环境中使用
        - 魔术方法:
            - print一个类实例,就是类调用了实例自身的__repr__方法
            - 一个实例+后一个实例,就是调用了该实例的__add__(后实例)方法
- 属性封闭 或 私有属性/方法:\_\_  两个_
- 抽象类(Abstract Base Classes):继承抽象类的子类,必须具有抽象类的方法
    - python3中抽象类的定义需要传参metaclass=abc.ABCMeta 再使用抽象类装饰器装饰内部函数
