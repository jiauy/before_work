- 封闭性:
   - 在类中保存数据
   - 封闭性的打破:i.e 可以直接修改类内部的变量,没有通过正确入口进入,可能会导致校验的缺失,对类中其他方法的使用带来问题.
   - 所以才有现在类中的\_\_init\_\_方法,私有属性等,防止类中的值被从外部直接修改
- 类属性:
  
    - 猜测:类和实例处于两个不同的内存空间,类有类属性,实例化后也有自己的实例属性,但是为了节约内存,实例当中不会拷贝类中所有的属性,只有在需要调用的时候才会去找.因此在没有对实例中的实例属性进行修改时,就对实例中的类属性进行删除,等价于对未实例化的类中的类属性进行删除,而对于这种行为,python是不支持的,会报错.但是如果在实例中,对实例的实例属性进行了修改,就能够使得调用实例属性时,不用再去从类中进行查找,此时再删除实例属性,就不会报错.删除后再调用实例属性,又会从类中进行引用.
    
- 类的继承:
    - 继承类拥有父类的属性和方法,相同功能条件下不必重写
    - 继承类并新建的类方法,并不会被其他继承相同父类的继承类所公用
- 多态:
    - 继承类有相同属性或方法,但功能不一样的现象
    - python内建方法中很多实现了多态,比如len(),其本质是调用对象的\_\_len\_\_方法,虽然都是len(),但是所对应的行为却并不一样,而是各自为战.
- 类同名方法或属性的继承或使用顺序:
    - 新式类-广度优先:Python3和Python2(object),新式类的MRO是按照 《拓扑排序算法》 规则，用的是C3算法。https://blog.csdn.net/u011467553/article/details/81437780
    
      快速记忆:![多继承UML图：](https://img-blog.csdn.net/20160912114102701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
    
      查找顺序是:A-B-D-C-E-F-O
    
        - 更为简单的方式是直接调用函数,查看调用顺序
        
          ```类.mro()```
    - 经典类-深度优先:Python2()
    - 为了减少重复查找,根节点会在后面的类中查找: D -> B -> A -> C -> A.优化为了D -> B -> C -> A
- 实例方法(instance method or bound method):
    - 通过'self'实现从类到实例的拷贝,表示的是实例的内存地址