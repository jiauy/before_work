## 入职准备

### Python

#### - OOD设计(个人初步感觉是软件工程中的一种常用思想.)

- 基本概念:是面向对象编程的整体思路与框架,本质上是为了减少工作量,和易用性,主要需要考虑以下几点:

  - 面向对象
  - 可复用
  - 能以最小代价满足变化
  - 不用改变现有代码满足扩展

- 基本原则:

  - 单一职能原则:对于基础对象来说是这样,对于高级对象也应该尽可能的在职责上有所区分,不要有重复的

  - 开放闭合原则:

    - 初步理解为面对同一个问题,一个类应该具有普适性,不因为问题的形式有所变化就固定死了.
    - 书面解释为:实现开放封闭的核心思想就是对[抽象编程](https://baike.baidu.com/item/抽象编程)，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以对修改就是封闭的；而通过[面向对象](https://baike.baidu.com/item/面向对象)的继承和对多态机制，可以实现对抽象体的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。

  - Liskov’s替换原则:

    - 初步理解:子类具有父类在测试中会用到的属性和特征和约束条件和产生的结果,那么负荷LSP原则的子类或更为明确是派生类,它不会改变这些会用到的属性和特征和约束条件和产生的结果,应该只是具有了新的行为,新的方法,新的属性.当把子类替换父类了之后,之前用到父类的代码还能够保持健壮性.

    - 举例:*使用* LSP的一个重要例子是**软件测试** 。

      如果我有一个类A是符合LSP的B类子类，那么我可以重用B的测试套件来测试A.

      我的`ATest`类将继承自`BTest` 。 然后需要某种形式的注入来确保测试用例适用于类型A而不是类型B的对象（简单的模板方法模式将会这样做）。

  - 接口分离原则:

    - 初步理解:不同功能不要写在一起,能分开就分开,只管调用接口,不要再写内部实现
    - 举例:
      - 接口-处理用户-不同用户有不同方法   **单一事件中包含的层级太多了**
      - 不同用户-接口-不同方法

  - 依赖倒置原则:

    - 涉及到的场景:

      - 项目中使用到了一个类,但是其子类放生了变化,导致该类需要改动很多,也就是子类依赖于其父类,这是正置
      - 项目中使用到的该类,应该是一个抽象的类,具体的实现取决于传入的参数,而不是内部的结构.为了保证传入参数(一个实例化对象方法的稳定性,在构造时应该让他们都继承自一个抽象的基类.)

    - 初步理解:首先对子类进行抽象,不因基类的不同而改变,其次对基类进行相同的抽象,使他们都具有相同的方法.这时候需要用到ABC的抽象方法

    - 书面解释:依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

    - 书面解释2:

      一个应用中的重要策略决定及业务模型正是在这些高层的模块中。也正是这些模型包含着应用的特性。但是，当这些模块依赖于低层模块时，低层模块的修改将会直接影响到它们，迫使它们也去改变。这种境况是荒谬的。应该是处于高层的模块去迫使那些低层的模块发生改变。应该是处于高层的模块优先于低层的模块。无论如何高层的模块也不应依赖于低层的模块。而且，我们想能够复用的是高层的模块。通过[子程序](https://baike.baidu.com/item/子程序)库的形式，我们已经可以很好地复用低层的模块了。当高层的模块依赖于低层的模块时，这些高层模块就很难在不同的环境中复用。但是，当那些高层[模块独立](https://baike.baidu.com/item/模块独立)于低层模块时，它们就能很简单地被复用了。这正是位于框架设计的最核心之处的原则。

      总结：依赖倒置原则

      A.高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。

      B.抽象不应该依赖于具体，具体应该依赖于抽象。

    - 参考链接

      - https://blog.csdn.net/ruguowoshiyu/article/details/81177852
      - https://www.cnblogs.com/Andy963/p/7111467.html

    - python特点:

      - python不支持多态也用不到多态，多态的概念是应用于java和C#这一类强类型语言中，而Python崇尚鸭子类型（Duck Typing）

      - 我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。

      - ```python
        rom abc import ABCMeta,abstractmethod
        
        class Payment(metaclass=ABCMeta):
            @abstractmethod                 #调用@abstractmethod规定子类必须有pay方法
            def pay(self,money):
                pass
        
            
        class Wechatpay(Payment):
            def pay(self,money):
                print('微信支付了%s元'%money)
        
                
        obj = Wechatpay()
        ```

  - 组合高于继承

  - 最小知识原则：这是说"你的类对其它类知晓得越少越好"【松耦合：类只与其协作的类进行交互，且无需了解它们的内部结构】

  - 共同封闭原则”：这是说"相关类应该打包在一起"【这样所有的修改都会发生在一个包中，而不是很多个】

  - 稳定抽象原则：这是说"类越稳定，越应该由抽象类组成"【稳定性跟抽象程度成正比，越是具体，越不稳定】

#### 	正则式:略

### NLP常用的分类技术

- https://blog.csdn.net/qq_41072222/article/details/103746397

### 数据库:mysql

- https://www.cnblogs.com/bigben0123/p/11233424.html

### ORM:

### 	- peewee

-  https://www.jianshu.com/p/8d1bdd7f4ff5

####      - sqlalchemy

- https://www.jb51.net/article/173950.htm

### web:FLASK

- 虚拟环境创建
  - https://docs.python.org/zh-cn/3.6/library/venv.html

​	