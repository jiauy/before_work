## 软降工程：解决如何依靠团队迅速开发出复合需求的软件产品的一些方法和规范或模式或规律

### 问题：

- 不像实体一样，可以直观理解，软件是一个逻辑产物，没有合适的图形来描述

- 软件开发如何高效，有序，可控
- 当代软件工程开发方法：敏捷开发，或者瀑布开发

### 软件工程过程：

- 软件开发活动

  - 问题定义
  - 需求开发
  - 软件设计
  - 软件构造
  - 软件测试

 - 软件开发管理

   - 软件项目管理计划
   - 软件配置管理计划
   - 软件质量保障计划
   - 评审记录

 - 软件工程工具

   ![image-20200929162909843](C:\Users\DIY\AppData\Roaming\Typora\typora-user-images\image-20200929162909843.png)

- 软件开发基本策略

  - 软件复用
  - 分而治之
  - 逐步演进
  - 优化折中

- 软件工程的规范

  - Wasserman规范

- 好的软件

  - 服务用户
  - 运行正确
  - 其他维度都可以考虑
  - ISO9126质量模型
  - 商业软甲，考虑成本利润等

### Python编程规范

- 注释规范，不冗余，标准，不仅易读，也可以用pydoc等方便生成文档
- 命名规范
  - 格式规范
  - 意义明确，可以少写注释
- 语句规范
  - 缩进要只用4个空格，除非在IDE中规定好了tab 等于4个空格
  - 类，驼峰
  - 变量，下划线
  - 等等https://www.cnblogs.com/wisir/p/10193149.html

### 提高方法

	- 看
	- 问
	- 练

### 模块化程序设计

- 功能分块
- 易变性分块
- 关键：抽象得到的各模块关键函数在后续开发中不应该发生改变，包括参数列表，名称，返回值等。
- 动手实践：声明游戏

### 代码静态检查

- https://www.bilibili.com/video/BV1Q741157ve?p=10
- Pylint代码分析工具 pip install pylint

### 结对编程：敏捷开发中，两名程序员用一台电脑一起编程

### 单元测试：

- 考虑内容：
   - 模块接口：参数表，模块IO等
   - 局部数据结构：数据类型，缺省值等
   - 边界条件
   - 独立路径
   - 出错处理
 - 原则：快速，独立，可重复，自我验证，及时编写（在开发实际的单元代码之前）
 - 过程：确定要单元测试的对象，可能不是所有的都能或都适合进行单元测试
 - 方法：动态或静态，白盒或黑盒。驱动模块用来模拟上层模块的调用行为；桩模块，用来模拟下层模块被调用的行为。（pytest）或PyUnit
 - 测试层次
    - xUnit
       - 函数
       - 类
    - Mock 虚拟：添加中间接口，下层调用虚拟出来一个符合要求的模块。这样可以解决引用错误。隔离了具体的模块。
       - 分布式，
       - 多线程，
       - 复杂依赖，
       - 有外界交互
       - 应用举例：抢票应用中国，调用系统函数来获得当前的系统时间，在测试中，如果时间没到，还需等待，而如果使用了mock，就可以随意设置时间。

- 测试用例

  - 设计要良好
    - 典型性和代表性
    - 针对设计和功能的薄弱点
    - 也要考虑错误或异常输入
    - 考虑用户实际使用场景

- 黑盒测试

  - 等价类划分：输入域划分，两两不相交，每个子域称为一个等价类
    - 从等价类中选取一个用例进行测试
    - 分类：有效等价类，无效等价类（用于容错测试等，是输入异常或错误的等价类），都要考虑和设计
    - 划分方法：
      - 输入域划分
      - 输出域划分：如三角形类别
  - 边界值分析，是对等价类的补充
     - 等价类的边界值
   - 错误推测法
      - 80%的错误集中在20%的代码中，精力可以分配的更多。
   - 测试覆盖
      - 考虑实际难易，成本等因素。标准如何等

 - 白盒测试

    - 更好的覆盖代码内部的流程

    - 方法：

       - 控制流图，根据它来设计测试用例

          - 代码覆盖标准

             - 代码覆盖率
                - 语句覆盖：要求每个**可执行语句**（赋值，计算，输出等操作）至少被执行一次
                - 判定覆盖：要求判断条件取真和取假的分支至少经历一次
                - 条件覆盖：每个判断中，每个条件的可能取值至少满足一次
                - 判定条件覆盖：条件覆盖，可能结果的也要覆盖（结果的真假）
                - 条件组合覆盖：条件不仅要覆盖，还要覆盖条件之间的组合
                - **路径覆盖**：覆盖程序执行中，所有可能的执行路径
                - 不盲目追求高的覆盖率，要考虑成本

          - 基本路径测试：测试**基本**可执行路径的集合，复杂度低的控制流

             - 环路复杂度：V(G)=判断节点数+1=区域数
             - 基本独立路径：至少包含一条新的边，正好等于环路复杂度

          - 循环测试(循环打破必有条件n)

             - 目的
                - 检查循环结构的有效性
             - 类型
                - 简单循环：循环次数为0,1,2，m<n,n-1,n,n+1
                - 嵌套：先测内层，外层设为最小值
                - 串接：简单循环的组合，或嵌套方法处理
                - 非结构

            - 方法
              - Z路径复杂下的循环测试：将循环结构简化为选择结构的一种路径覆盖，为了限定循环次数，只考虑执行循环体一次货零次

- 单元测试工具：https://www.bilibili.com/video/BV1Q741157ve?p=19

  - 内置unittest

  - 内置mock：

    - Mock类，当访问mock对象的某个属性时，mock对象会自动创建该属性
    - MagicMock类，Mock的子类，预先定义了魔术方法
    - patch装饰器：可以用在测试方法上，限定条件是测试方法使用mock来替换真实对象
    - 属性断言，判断mock对象是否被调用
    - 行为控制，模拟被替换对象方法的返回值

  - 覆盖分析pip install coverage.py,在pycharm中很方便的与unittest一起运行

  - pycharm 单元测试流程

    - 菜单栏navigate
    - 测试的方法相互联系，可以合并为一个测试
    - 测试完毕后覆盖率分析，对没有覆盖的地方进行静态分析检查。

  - 其他工具

    ![image-20200930115029944](C:\Users\DIY\AppData\Roaming\Typora\typora-user-images\image-20200930115029944.png)

### 软件过程

- 含义：将输出转化为输出的一些列相互关联或相互作用的活动。
- 分类：
  - 管理过程
  - 实现过程
  - 支持过程
- 应用：
  - 过程的设计
  - 过程的监控

- 软件过程理解：
  - 产品经理设计产品
  - 软件设计设计软件
    - 软件需求规格说明
    - 体系结构
    - 接口设计
    - 组件设计
    - 数据库设计
    - 软件设计说明书
  - 软件构造
  - 软件测试
  - 软件维护
- 开发管理
  - 项目管理
    - 计划
    - 领导
    - 组织
    - 控制
  - 配置管理
    - 组件版本
    - 系统版本
    - 系统发布
    - 系统变更
- 软件过程模型
  - 瀑布模型（广泛）：线性开发，计划驱动，有利于规范开发活动
    - 文档驱动，预见性开发，但预测并不能完全实现，测试的时候，软件已经初步开完了，现在逐步被淘汰
    - 适用条件：能够很好的确定产品的需求，后期改动小的产品
  - 原型化模型：部分开发的模型，有助于对系统的理解，比如UI构造一个软件模样，功能是否是用户需要的等。
  - 迭代式开发
    - 增量迭代，新功能
    - 质量迭代，功能质量更好
  - 可转化模型：形式化的数学描述，主要应用于嵌入系统
  - **敏捷开发**：增量+迭代
    - 宣言
      - 个体和交互 胜于过程和工具
      - 可工作的软件 胜过面面俱到的文档
      - 客户合作胜过合同谈判
      - 响应变化 胜过遵循计划
    - 本质：与客户有效沟通，时刻反馈交流，确定符合用户的需求
    - 敏捷开发值scrum：https://www.bilibili.com/video/BV1Q741157ve?p=30
      - 框架
        - 团队角色
        - 团队活动
        - 团队制品

### 团队管理

- 组织管理
  - 组织模式
  - 绩效考核
- 沟通管理：成功的85%取决于沟通
  - 沟通团队规模 3~7人
  - 项目经理：是沟通的核心人物

### 软件项目计划

https://www.bilibili.com/video/BV1Q741157ve?p=28

### 软件项目估算

https://www.bilibili.com/video/BV1Q741157ve?p=29

软件工程初步总结

- 用户--（用户故事）--产品经理----项目经理---项目团队

### 软件需求工程

- https://www.bilibili.com/video/BV1Q741157ve?p=36

- UML统一建模语言

- EA 较好的统一建模语言的建模工具

![image-20200930144947789](C:\Users\DIY\AppData\Roaming\Typora\typora-user-images\image-20200930144947789.png)

### 面向对象分析

- https://www.bilibili.com/video/BV1Q741157ve?p=51

- 初步理解：把软件开发的分析，当做一个个对象，他们之间有联系
- 局限性很大，一般较少采用，除非特别适合
- 应用举例：
  - 开发一个21点的游戏，如何设计呢？
  - 面向对象分析的设计包括
    - 识别类，从需求中提取名词信息，提出对需求整体的指代，过于具体或过于模糊的名词
    - 类的职责，候选类中的动词扫描，可作为潜在职责
    - 类的交互行为 UML分析
  - 方法：CRC卡片识别法
- 优点：封装，复用，模块化
- 核心思想
  - 区分接口和实现
    - 关键是接口的标准化（比如使用配置文件中的ENV,通过修改ENV继承的类改变具体实现）
    - 面向服务的原则
    - 接口是外部来使用对象调用的部分，不关注是怎么实现的，只要给出想要的返回值即可。
    - OOP中的 SOLID
      - 单一功能原则
      - 开放封闭原则：类中包含了某种功能，这个功能不应该在该类中实现，而应该作为一个接口被调用。这样当类中该功能发生变动，不需要修改这个类，只用修改接口的内部实现就可以。
      - Liskov替换原则：子类可以扩展新功能，但是尽量不要**重写/重载**父类的接口。
      - 依赖倒置原则：就是主程序尽量依靠接口类（抽象类），而非实现类或具体类
      - 接口分离原则（需要权衡）：接口的复杂度设计，分离的粒度。
  - 从具体到抽象
  - 最小接口原则

#### 软件过程之软件开发过程初步总结：

- 对需求进行分析与转化，首先是建模，然后是把建好的模型转化为代码的设计（如一个个类对象）

- https://www.bilibili.com/video/BV1Q741157ve?p=52

#### 软件工程之建模:需要对软件的行为进行准确的描述，开发才能更快。UML语言

理解：自然语言描述模型---建模工具进一步帮助理清业务逻辑--及技术逻辑等

思考：工程经验----开发可复用模块，标准化组件设计

- 高级建模
  - 结构图
    - 类图（基础）**最常用**
    - 组分图
    - 对象图
    - 部署图
    - 打包图
    - 组合结构图
    - 文件图
  - 行为图
    - 活动图
    - 使用情景图
    - 状态机：UML中用来标识一个类的全生命周期过程，对自身状态的检查和管理
      - 前提条件：所有对象都必须有状态
      - 状态
        - 对象状态空间：注意不存在也是一种状态，例题:具有5个布尔值属性的对象具有多少个状态，答案是2^5+1
        - 具体状态和抽象状态
          - 具体状态可能无穷尽，我们只关心所关心的状态。
          - 现实对象的状态
          - 信息对象的状态
          - 实体状态
          - 愿望状态
          - 应用领域实体的可观测状态和行为
          - 机器领域实体的具体行为和状态
      - 有限状态机的主要元素
        - 状态和转移
        - 事件和行为
      - 模块化的状态机模型：状态图
        - 组合状态和子状态
        - 绘制状态图的方法
      - 状态图建模风格
        - 初始态左上角，最终态右下角
        - 用过去式明明转移事件
        - 境界条件不重叠
        - 不要把境界条件置于厨师转移之上
    - 交互图---交流图
    - 顺序图--**次常用**
      - 对象
        - 表示方法
          - \<objectname\>：\<classname\>
          - :\<classname\>   匿名对象
          - object  未知对象
      - 生命线
      - 消息
        - **同步消息**
        - 异步消息
        - 返回消息
        - 自关联消息
        - 超时等待
        - 阻塞
      - 绘制方法
        - 对象：矩形框
        - 生命线：竖直虚线
        - 消息:类之间的箭头
        - 激活期：生命线下的竖直矩形，表明对象正在进行某操作
        - 自定义添加框表示复杂的控制结构和组合关联
      - 集中控制 or 分布式控制
        - 命令集中于单个对象的程度来区分，建议用分布式，降低等待时间。
      - 建模风格（建议）
        - 注意力集中在关键位置的交互：根据建模目的，重点描述目的相关的环节，如有的建模目的是描述业务逻辑，而非技术逻辑
        - 对于参数，优先考虑使用参数名（如总额）而不是参数类（如账户)，参数类应该用UML语言单独定义，不用出现在参数中
        - 不建议对明显的返回值建模说明
        - 可以把返回值建模为方法调用的一部分
    - 交互总览图 
    - 时机图

#### 软件体系结构

代码级别的复用远远不够偷懒，需要抽象出更高的层次来满足工程需求。

- 不同层次的关注点

  - 小程序，小功能：eg词频统计程序
    - 算法的选择
    - 数据结构的设计
    - 数据库的构造
  - 大程序，大功能：百度
    - 系统的全局设计和规划

- 基础概念

  软件体系结构包括构成系统的设计元素的描述，设计元素之间的交互，设计元素的组合模式，以及这些模式中的约束

  （构件、连接件，物理分部，约束，质量）

- 其他概念

  体系结构风格：MTV这种，目的是改善代码结构，提高程序的结构质量

  设计模式：如观察者模式

  软件框架：如django这种，强调设计的重用性和可扩展性，缩短开发周期。

- 软件设计原则
  - 抽象
  - 封装和信息隐藏
  - 模块化，高内聚（行为类似，元素相关）低耦合（模块间依赖强度低）
  - 层次化
  - 复用

- 早期或常见的软件体系结构风格

  - 独立构件

    - 进程通信

    - 事件系统风格：如IDE

      - 显式调用
      - 隐式调用

      - 实现策略
        - 选择广播式（发布者-订阅者）
        - 观察者模式

  - 数据流

    - 批处理
    - **管道过滤器**，不适合交互场景
      - 媒体播放器：数据文件经过分离器，把对应数据传送到视频解码器和音频解码器中，然后再分别传输到显示器和声卡

  - 以数据为中心

    - **仓库**：缺点，耦合度高
      - 如剪贴板
    - 黑板

  - 虚拟机

    - 解释器
    - 基于规则的系统

  - 调用/返回

    - **主程序和子程序**
    - **面向对象**
    - **层次结构**

  - 实际应用：

    - 风格的选择需要丰富的经验
    - 往往软件的不同层次会使用到不同的风格，需要确定好顶层风格，和各层次或局部的风格。

#### 软件设计过程

- 交互设计UI
- **系统总体设计**
  - 明确目标
  - 确定子系统或模块
  - 选择系统部署方案
  - 定义设计策略
  - 评审系统设计方案
- 模块设计与实现

#### 数据库的选择

https://www.bilibili.com/video/BV1Q741157ve?p=71

#### 交互设计：操作时间，心理考量等指标的综合优化

- 概述：用户与软件的交互，构件之间的交互等
- 目标
- GUI设计原则：
  - 学习成本，记忆成本，交互效率，满意程度
  - 设计规则
    - **可视化**
    - 一致性
    - 直接映射
    - 有效反馈
- 效率测算：用户减少实现点击等操作的耗时，可以想各种办法。
  - KLM效率模型，测量交互任务完成的时间，基于模型进行效率优化
  - Fitts定律：GUI中体现为鼠标指针与对象的距离和时间关系等。简单来说，图标要大，间距要小。
  - 交互设计过程

#### 软件测试

- 概念
  - 正向思维:验证软件正常工作
  - 逆向思维：假定软件有缺陷

- 目标
  - 最低成本和代价找到软件的错误和缺陷
- 测试的局限性
- 测试应尽早引入
- 杀虫剂效应：测试用例应该多评审维护
- 测试需要的思维
  - **逆向思维**
  - **发散思维**
  - 两极思维
  - 组合思维
  - 系统思维
  - 比较思维
  - 简单思维

- 过程
  - 计划
  - 准备
  - 执行
  - 报告
- 测试层次
  - 设计审查
  - 单元测试
  - 集成测试
  - 功能测试：能够实现所需功能
  - 性能测试：能够顺利的，令人满意的实现功能
  - 验收测试：测试用户来提意见
  - 安装测试：用户环境下
- 测试类型
  - 测试对象角度:单元测试等
  - 测试技术角度：黑盒白盒测试
  - 程序执行角度：静态动态
  - 人工干预角度：手工 自动化

### 总结：

软件工程，是一门通过各种手段，提高软件设计质量，提高用户使用感受，减少软件设计时间，降低软件设计成本的一门学问。

